#!/usr/bin/env node
/**
 * Interactive Product Import Script
 *
 * Responsibilities:
 * 1. Extract product category zip files inside public/CBCProducts.zip (nested zips) to a temp folder.
 * 2. For each category zip, list contained images.
 * 3. Prompt user for base product details (or auto-generate sensible defaults) per image:
 *    - productID (autogenerated if blank: CATNAME-<n>)
 *    - name (derived from filename)
 *    - altNames (category name + derived tokens)
 *    - price / labeledPrice (random realistic within range unless overridden)
 *    - stock
 *    - description (templated from category + name)
 * 4. Upload each image to Supabase storage (bucket: site-images/products/<category>/filename)
 * 5. POST product to backend API (expects VITE_BACKEND_URL + /api/products) with Authorization Bearer token.
 *
 * Usage:
 *   1. Ensure .env.local (or environment) defines:
 *      - VITE_SUPABASE_URL
 *      - VITE_SUPABASE_ANON_KEY
 *      - VITE_BACKEND_URL
 *      - API_TOKEN (admin JWT) OR set token when prompted.
 *   2. Run: npm run import:products
 */
import fs from 'fs';
import path from 'path';
import readline from 'readline';
import AdmZip from 'adm-zip';
import axios from 'axios';
import { createClient } from '@supabase/supabase-js';
import dotenv from 'dotenv';

dotenv.config({ path: path.resolve(process.cwd(), '.env.local') });

const ROOT = process.cwd();
const PUBLIC_DIR = path.join(ROOT, 'public');
const MASTER_ZIP = path.join(PUBLIC_DIR, 'CBCProducts.zip');
const TEMP_DIR = path.join(ROOT, 'tmp', 'product-import');

const supabaseUrl = process.env.VITE_SUPABASE_URL;
const supabaseKey = process.env.VITE_SUPABASE_ANON_KEY;
const backendUrl = process.env.VITE_BACKEND_URL;
const bucket = 'site-images';

if (!supabaseUrl || !supabaseKey) {
  console.error('Missing Supabase credentials in env. Aborting.');
  process.exit(1);
}
if (!backendUrl) {
  console.error('Missing VITE_BACKEND_URL in env. Aborting.');
  process.exit(1);
}

const supabase = createClient(supabaseUrl, supabaseKey);

function ensureDir(dir) {
  fs.mkdirSync(dir, { recursive: true });
}

function cleanTemp() {
  if (fs.existsSync(TEMP_DIR)) {
    fs.rmSync(TEMP_DIR, { recursive: true, force: true });
  }
  ensureDir(TEMP_DIR);
}

async function extractMasterZip() {
  if (!fs.existsSync(MASTER_ZIP)) {
    throw new Error(`Master zip not found at ${MASTER_ZIP}`);
  }
  const zip = new AdmZip(MASTER_ZIP);
  zip.extractAllTo(TEMP_DIR, true);
}

function listCategoryZips() {
  return fs.readdirSync(TEMP_DIR)
    .filter(f => f.toLowerCase().endsWith('.zip'))
    .map(f => path.join(TEMP_DIR, f));
}

function extractCategoryZip(zipPath) {
  const dest = zipPath.replace(/\.zip$/i, '');
  ensureDir(dest);
  const zip = new AdmZip(zipPath);
  zip.extractAllTo(dest, true);
  return dest;
}

function deriveNameFromFile(file) {
  return path.basename(file).replace(/[-_]+/g, ' ').replace(/\.[^.]+$/, '')
    .replace(/\s+\d+$/, '') // drop trailing numbers
    .replace(/\b(img|image|photo)\b/ig, '')
    .replace(/\s+/g, ' ')    // collapse spaces
    .trim()
    .replace(/\b\w/g, c => c.toUpperCase());
}

function randomPrice(base = 15, variance = 20) {
  const p = base + Math.random() * variance;
  return Math.round(p * 100) / 100;
}

async function uploadImage(filePath, category) {
  const fileBuf = fs.readFileSync(filePath);
  const fileName = path.basename(filePath);
  const storagePath = `products/${category}/${Date.now()}-${Math.random().toString(36).slice(2)}-${fileName}`;
  const { error } = await supabase.storage.from(bucket).upload(storagePath, fileBuf, {
    contentType: 'image/' + (fileName.split('.').pop() || 'jpeg'),
    upsert: false
  });
  if (error) throw error;
  const { data } = supabase.storage.from(bucket).getPublicUrl(storagePath);
  return data.publicUrl;
}

async function createProduct(product, token) {
  const url = `${backendUrl}/api/products`;
  const res = await axios.post(url, product, {
    headers: { Authorization: `Bearer ${token}` }
  });
  return res.data;
}

function ask(query, rl) {
  return new Promise(resolve => rl.question(query, ans => resolve(ans)));
}

async function main() {
  console.log('=== Crystal Beauty Clear Product Import ===');
  cleanTemp();
  console.log('Extracting master zip...');
  await extractMasterZip();
  const catZips = listCategoryZips();
  if (!catZips.length) {
    console.log('No category zip files found inside master zip.');
    return;
  }
  console.log(`Found ${catZips.length} category archives.`);

  const rl = readline.createInterface({ input: process.stdin, output: process.stdout });
  let token = process.env.API_TOKEN;
  if (!token) {
    token = await ask('Enter admin JWT token: ', rl);
  }

  for (const catZip of catZips) {
    const baseName = path.basename(catZip, '.zip');
    console.log(`\n--- Category: ${baseName} ---`);
    const catDir = extractCategoryZip(catZip);
    const images = fs.readdirSync(catDir).filter(f => /\.(png|jpe?g|webp|gif)$/i.test(f)).map(f => path.join(catDir, f));
    if (!images.length) {
      console.log('No images in category zip, skipping.');
      continue;
    }

    let index = 1;
    for (const img of images) {
      const defaultName = deriveNameFromFile(img);
      const name = await ask(`Product name [${defaultName}]: `, rl) || defaultName;
      const productID = await ask(`Product ID [${baseName.toUpperCase()}-${index}]: `, rl) || `${baseName.toUpperCase()}-${index}`;
      const altInput = await ask(`Alt names (comma) [${baseName}, ${defaultName}]: `, rl) || `${baseName}, ${defaultName}`;
      const altNames = Array.from(new Set(
        altInput
          .split(',')
          .map(s => s.trim())
          .filter(Boolean)
          .concat(
            // Add individual tokens from category zip filename for better search / alt coverage
            baseName.split(/[-_]+/).map(t => t.trim()).filter(Boolean)
          )
      ));
      const priceStr = await ask(`Price [auto]: `, rl);
      const labeledPriceStr = await ask(`Labeled Price [auto]: `, rl);
      const price = priceStr ? parseFloat(priceStr) : randomPrice(18, 22);
      const labeledPrice = labeledPriceStr ? parseFloat(labeledPriceStr) : Math.max(price + randomPrice(5, 10), price + 1);
      const stockStr = await ask(`Stock [50]: `, rl) || '50';
      const stock = parseInt(stockStr, 10) || 50;
      const descDefault = `Premium ${defaultName} from our ${baseName} collection designed to enhance natural beauty and skin health.`;
      const description = await ask(`Description [auto]: `, rl) || descDefault;

      process.stdout.write(' Uploading image...');
      let imageUrl;
      try {
        imageUrl = await uploadImage(img, baseName);
        console.log(' done');
      } catch (e) {
        console.error('\n Image upload failed:', e.message);
        const retry = await ask(' Skip product? (y/N): ', rl);
        if (/^y/i.test(retry)) continue; else return;
      }

      const product = {
        productID,
        name,
        altNames,
        category: baseName.replace(/[-_]/g, ' ').replace(/\b\w/g, c => c.toUpperCase()),
        brand: 'Crystal Beauty Clear',
        price,
        labeledPrice,
        quantity: stock, // maintain both maybe backend uses quantity
        stock,
        isAvailable: stock > 0,
        rating: 4.5,
        description,
        imageUrl: [imageUrl]
      };

      process.stdout.write(' Creating product...');
      try {
        await createProduct(product, token);
        console.log(' created');
      } catch (e) {
        console.error('\n Product creation failed:', e.response?.data || e.message);
        const retry = await ask(' Continue with next? (Y/n): ', rl);
        if (/^n/i.test(retry)) {
          rl.close();
          return;
        }
      }
      index++;
    }
  }
  rl.close();
  console.log('\nAll done.');
}

main().catch(e => {
  console.error('Fatal error:', e);
  process.exit(1);
});
